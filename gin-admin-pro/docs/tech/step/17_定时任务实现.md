# 定时任务实现

## 实现思路

本阶段实现了完整的定时任务调度系统，基于robfig/cron库，提供了企业级的任务调度解决方案。

## 技术选型

### 核心库
- **robfig/cron/v3**: 选择v3版本，支持更丰富的Cron表达式和更好的性能
- **标准库context**: 用于任务取消和超时控制
- **sync包**: 用于并发控制和线程安全

### 架构设计
```
plugin/cron/
├── config.go          # 配置管理
├── types.go           # 数据类型和接口定义
├── cron.go            # 核心管理器
├── registry.go        # 注册器和执行器实现
├── cron_test.go       # 单元测试
└── README.md          # 使用文档
```

## 核心功能实现

### 1. 配置管理 (config.go)

#### 设计思路
- 支持完整的任务配置参数
- 提供合理的默认值
- 支持YAML配置文件映射
- 灵活的任务元数据管理

#### 关键特性
```go
type Config struct {
    // 基础配置
    Enabled     bool
    Timezone    string
    Concurrency int
    
    // 任务配置
    Jobs        []*JobConfig
    
    // 执行配置
    Timeout     time.Duration
    MaxRetries  int
    RetryDelay  time.Duration
    
    // 管理配置
    LogEnabled  bool
    ManagementEnabled bool
}

type JobConfig struct {
    // 基础信息
    ID          string
    Name        string
    Description string
    Enabled     bool
    
    // 调度配置
    Cron        string
    Timezone    string
    
    // 执行配置
    Handler     string
    Timeout     time.Duration
    MaxRetries  int
    RetryDelay  time.Duration
    
    // 参数和元数据
    Params      map[string]interface{}
    Tags        []string
    Metadata    map[string]string
    
    // 依赖和限制
    DependsOn   []string
    MaxInstances int
    Singleton   bool
}
```

### 2. 类型系统 (types.go)

#### 设计思路
- 定义完整的任务生命周期接口
- 提供灵活的处理器接口
- 支持事件监听和指标收集
- 实现线程安全的状态管理

#### 核心接口
```go
// Job 任务接口
type Job interface {
    GetID() string
    GetName() string
    GetStatus() JobStatus
    IsEnabled() bool
    IsRunning() bool
    Execute(ctx, params) error
    Cancel() error
    Pause() error
    Resume() error
    GetDependsOn() []string
    CheckDependencies() bool
    GetTags() []string
    GetMetadata() map[string]string
}

// JobHandler 任务处理器接口
type JobHandler interface {
    Handle(ctx, job, params) error
    OnStart(ctx, job) error
    OnComplete(ctx, job, err) error
    OnError(ctx, job, err) error
    OnRetry(ctx, job, attempt, err) error
}

// JobRegistry 任务注册器接口
type JobRegistry interface {
    RegisterHandler(name, handler) error
    GetHandler(name) (JobHandler, error)
    ListHandlers() []string
    UnregisterHandler(name) error
}

// JobExecutor 任务执行器接口
type JobExecutor interface {
    Execute(ctx, job) error
    GetExecutionHistory(jobID, limit) ([]*JobExecution, error)
    GetRunningJobs() []Job
    CancelExecution(jobID) error
}
```

### 3. 核心管理器 (cron.go)

#### 设计思路
- 统一的任务调度和管理
- 支持动态任务添加和删除
- 实现优雅的启动和关闭
- 提供事件监听机制

#### 关键功能
```go
type CronManager struct {
    config    *Config
    cron      *cron.Cron
    registry  JobRegistry
    executor  JobExecutor
    
    jobs      map[string]Job
    handlers  map[string]JobHandler
    
    // 执行管理
    runningJobs map[string]context.CancelFunc
    
    // 事件管理
    eventHandlers []EventHandler
    
    // 状态管理
    started   bool
    ctx       context.Context
    cancel    context.CancelFunc
    wg        sync.WaitGroup
}
```

### 4. 注册器和执行器 (registry.go)

#### 设计思路
- 提供默认的注册器实现
- 实现完整的执行器功能
- 支持执行历史记录
- 提供示例处理器

#### 默认处理器
```go
// SampleJobHandler 示例任务处理器
type SampleJobHandler struct{}

// CleanupJobHandler 清理任务处理器
type CleanupJobHandler struct{}

// ReportJobHandler 报告任务处理器
type ReportJobHandler struct{}
```

## 高级特性

### 1. 任务依赖管理

实现任务依赖关系检查，确保前置任务完成后才执行后续任务：

```go
func (cm *CronManager) checkDependencies(job Job) bool {
    dependsOn := job.GetDependsOn()
    for _, depID := range dependsOn {
        if depJob, exists := cm.jobs[depID]; exists {
            if !depJob.IsEnabled() || depJob.GetStatus() != JobStatusCompleted {
                return false
            }
        }
    }
    return true
}
```

### 2. 单例任务控制

防止任务重复执行，确保同一时间只有一个实例在运行：

```go
// 检查单例任务
if config.Singleton && job.IsRunning() {
    log.Printf("Job %s is singleton and already running, skipping", job.GetID())
    return
}
```

### 3. 重试机制

实现智能重试，支持退避策略和错误分类：

```go
// 执行任务，包含重试逻辑
for attempt := 0; attempt <= config.MaxRetries; attempt++ {
    if attempt > 0 {
        select {
        case <-time.After(config.RetryDelay):
        case <-ctx.Done():
            return ctx.Err()
        }
        
        // 调用重试回调
        if err := handler.OnRetry(ctx, job, attempt, lastErr); err != nil {
            log.Printf("Job %s retry callback failed: %v", job.GetID(), err)
        }
    }
    
    err := handler.Handle(ctx, job, config.Params)
    if err == nil {
        return nil // 成功
    }
    
    lastErr = err
}
```

### 4. 事件监听

实现完整的事件系统，支持任务生命周期监控：

```go
type JobEvent struct {
    Type      string      // started, completed, failed, cancelled, paused, resumed
    JobID     string
    JobName   string
    Timestamp time.Time
    Data      interface{}
}

// 发送事件
cm.emitEvent(&JobEvent{
    Type:      "started",
    JobID:     job.GetID(),
    JobName:   job.GetName(),
    Timestamp: time.Now(),
})
```

## 使用示例

### 基础使用

```go
// 创建管理器
config := cron.DefaultConfig()
config.Timezone = "Asia/Shanghai"

manager, err := cron.NewCronManager(config)
if err != nil {
    panic(err)
}

// 初始化和启动
err = manager.Initialize()
if err != nil {
    panic(err)
}

err = manager.Start()
if err != nil {
    panic(err)
}
defer manager.Stop()

// 添加任务
jobConfig := &cron.JobConfig{
    ID:      "cleanup",
    Name:    "清理任务",
    Enabled: true,
    Cron:    "0 2 * * *", // 每天凌晨2点
    Handler: "cleanup",
    Timeout: time.Hour,
    MaxRetries: 2,
}

err = manager.AddJob(jobConfig)
if err != nil {
    panic(err)
}
```

### 自定义处理器

```go
type MyJobHandler struct{}

func (h *MyJobHandler) Handle(ctx context.Context, job cron.Job, params map[string]interface{}) error {
    log.Printf("Executing job: %s", job.GetID())
    
    // 业务逻辑
    err := doSomeWork(ctx)
    if err != nil {
        return err
    }
    
    return nil
}

// 注册处理器
myHandler := &MyJobHandler{}
registry := manager.GetRegistry()
registry.RegisterHandler("my-job", myHandler)

// 使用自定义处理器
jobConfig := &cron.JobConfig{
    ID:      "custom-job",
    Name:    "自定义任务",
    Enabled: true,
    Cron:    "*/30 * * * *", // 每30分钟
    Handler: "my-job",
}

manager.AddJob(jobConfig)
```

### 事件监听

```go
type MonitoringHandler struct{}

func (h *MonitoringHandler) Handle(event *cron.JobEvent) error {
    switch event.Type {
    case "started":
        metrics.Counter("job_started_total").Inc()
    case "completed":
        metrics.Counter("job_completed_total").Inc()
    case "failed":
        metrics.Counter("job_failed_total").Inc()
        // 发送告警
        alert.Send(event)
    }
    return nil
}

// 添加事件监听器
monitoringHandler := &MonitoringHandler{}
manager.AddEventHandler(monitoringHandler)
```

## Cron表达式支持

### 标准格式
```
分 时 日 月 周
*  *  *  *  *
```

### 特殊字符
- `*`: 任意值
- `,`: 多个值 (1,3,5)
- `-`: 范围 (1-5)
- `/`: 步长 (*/5)
- `?`: 不指定值 (仅用于日和周)

### 常用表达式
```
*/5 * * * *      # 每5分钟
0 */1 * * *      # 每小时
0 2 * * *        # 每天凌晨2点
0 2 * * 1        # 每周一凌晨2点
0 1 1 * *        # 每月1号凌晨1点
0 0 1 1 *        # 每年1月1号午夜
```

## 配置参数详解

### 全局配置

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `enabled` | bool | true | 是否启用定时任务 |
| `timezone` | string | "UTC" | 时区设置 |
| `concurrency` | int | 100 | 最大并发数 |
| `timeout` | duration | 30m | 默认任务超时时间 |
| `maxRetries` | int | 3 | 默认重试次数 |
| `retryDelay` | duration | 5s | 重试间隔 |
| `logEnabled` | bool | true | 是否启用日志 |
| `logLevel` | string | "info" | 日志级别 |
| `managementEnabled` | bool | true | 是否启用管理接口 |

### 任务配置

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `id` | string | 必填 | 任务唯一标识 |
| `name` | string | 必填 | 任务名称 |
| `description` | string | "" | 任务描述 |
| `enabled` | bool | true | 是否启用 |
| `cron` | string | 必填 | Cron表达式 |
| `handler` | string | 必填 | 处理器名称 |
| `timeout` | duration | 30m | 任务超时时间 |
| `maxRetries` | int | 3 | 重试次数 |
| `retryDelay` | duration | 5s | 重试间隔 |
| `dependsOn` | []string | [] | 依赖任务ID列表 |
| `singleton` | bool | true | 是否为单例任务 |
| `maxInstances` | int | 1 | 最大并发实例数 |
| `params` | map | {} | 任务参数 |
| `tags` | []string | [] | 任务标签 |
| `metadata` | map | {} | 任务元数据 |

## 性能优化

### 1. 并发控制

```yaml
cron:
  concurrency: 50  # 根据服务器配置调整
```

### 2. 任务分组

```go
// 将相关任务分组，避免同时执行大量IO密集型任务
jobConfig := &cron.JobConfig{
    ID:   "io-intensive-job",
    Cron: "0 3 * * *",  # 统一在低峰期执行
    Tags: ["io-intensive", "maintenance"],
}
```

### 3. 资源监控

```go
type ResourceAwareHandler struct{}

func (h *ResourceAwareHandler) Handle(ctx context.Context, job cron.Job, params map[string]interface{}) error {
    // 检查系统资源
    if h.isSystemBusy() {
        return fmt.Errorf("system too busy, deferring job")
    }
    
    return h.doWork(ctx, params)
}
```

## 监控和运维

### 1. 执行历史

```go
// 获取执行历史
executor := manager.GetExecutor()
history, err := executor.GetExecutionHistory("job-id", 100)
for _, execution := range history {
    log.Printf("Execution %s: %s, Duration: %v", 
        execution.ID, execution.Status, execution.Duration)
}
```

### 2. 状态监控

```go
// 获取所有任务状态
jobs := manager.ListJobs()
for _, job := range jobs {
    log.Printf("Job %s: Status=%s, Enabled=%v, Running=%v", 
        job.GetID(), job.GetStatus(), job.IsEnabled(), job.IsRunning())
}
```

### 3. 指标收集

```go
// 自定义指标处理器
type MetricsHandler struct{}

func (h *MetricsHandler) Handle(event *cron.JobEvent) error {
    metrics.Counter("cron_job_events_total").WithLabelValues(
        event.Type, event.JobID,
    ).Inc()
    
    if event.Type == "completed" {
        metrics.Histogram("cron_job_duration_seconds").Observe(
            time.Since(event.Timestamp).Seconds(),
        )
    }
    
    return nil
}
```

## 错误处理和恢复

### 1. 任务失败处理

```go
func (h *RobustJobHandler) OnError(ctx context.Context, job cron.Job, err error) error {
    // 记录详细错误信息
    log.Printf("Job %s failed: %v", job.GetID(), err)
    
    // 根据错误类型决定处理策略
    if errors.Is(err, context.DeadlineExceeded) {
        log.Printf("Job %s timed out, increasing timeout", job.GetID())
        // 可以动态调整超时时间
    }
    
    // 发送告警
    if h.requiresAlert(err) {
        h.sendAlert(job, err)
    }
    
    return nil
}
```

### 2. 系统故障恢复

```go
// 优雅关闭
func (cm *CronManager) Stop() error {
    // 取消所有运行中的任务
    cm.runningMu.Lock()
    for jobID, cancel := range cm.runningJobs {
        cancel()
        log.Printf("Cancelled running job: %s", jobID)
    }
    cm.runningMu.Unlock()
    
    // 停止cron调度器
    ctx := cm.cron.Stop()
    select {
    case <-ctx.Done():
        log.Println("Cron manager stopped gracefully")
    case <-time.After(time.Second * 10):
        log.Println("Cron manager stop timeout, forcing stop")
    }
    
    return nil
}
```

## 测试策略

### 1. 单元测试覆盖

- ✅ 配置构建和验证
- ✅ 管理器创建和初始化
- ✅ 任务添加、删除、查询
- ✅ 任务执行控制（启动、暂停、恢复）
- ✅ 注册器功能
- ✅ 执行器功能
- ✅ 事件处理

### 2. 集成测试

- 任务调度和执行
- 依赖关系处理
- 重试机制验证
- 并发执行测试

### 3. 性能测试

```go
func BenchmarkJobExecution(b *testing.B) {
    manager := setupTestManager()
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        manager.RunJob("test-job", nil)
        time.Sleep(time.Millisecond) // 避免过度并发
    }
}
```

## 部署建议

### 生产环境配置

```yaml
cron:
  enabled: true
  timezone: "UTC"  # 统一使用UTC
  concurrency: 20   # 保守的并发数
  timeout: 1h
  maxRetries: 3
  retryDelay: 10m
  logLevel: "info"
  
  jobs:
    # 核心业务任务
    - id: "data-sync"
      enabled: true
      cron: "0 */6 * * *"
      handler: "sync"
      timeout: 2h
      maxRetries: 5
      
    # 维护任务
    - id: "cleanup"
      enabled: true
      cron: "0 2 * * *"
      handler: "cleanup"
      timeout: 3h
      singleton: true
```

### 监控告警

- 任务执行成功率 > 95%
- 平均执行时间 < 预期时间
- 失败任务立即告警
- 长时间运行任务告警
- 系统资源使用率监控

## 扩展开发

### 自定义执行器

```go
type DistributedExecutor struct {
    cluster *ClusterClient
}

func (e *DistributedExecutor) Execute(ctx context.Context, job cron.Job) error {
    // 选择执行节点
    node := e.cluster.SelectNode()
    
    // 分发任务到指定节点
    return e.cluster.ExecuteOnNode(ctx, job, node)
}
```

### 集成外部系统

```go
type DatabaseJobHandler struct {
    db *sql.DB
}

func (h *DatabaseJobHandler) Handle(ctx context.Context, job cron.Job, params map[string]interface{}) error {
    // 执行数据库操作
    _, err := h.db.ExecContext(ctx, "CALL cleanup_procedure()")
    return err
}
```

## 总结

定时任务插件提供了完整的任务调度解决方案：

1. **强大的调度**: 基于标准Cron表达式，支持时区
2. **灵活的管理**: 动态添加、删除、暂停、恢复任务
3. **可靠的执行**: 重试机制、超时控制、错误处理
4. **完善的监控**: 事件系统、执行历史、指标收集
5. **易于扩展**: 插件化架构，支持自定义处理器和执行器
6. **生产就绪**: 并发控制、资源管理、优雅关闭

该实现为企业级应用提供了可靠、高性能的定时任务管理功能。