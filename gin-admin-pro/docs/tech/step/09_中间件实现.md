# 中间件实现

## 概述

本文档记录了项目中所实现的中间件功能，包括限流、认证、权限、操作日志和异常处理等中间件的实现细节。

## 实现的中间件

### 1. 限流中间件 (RateLimit)

#### 文件位置
`internal/middleware/rate_limit.go`

#### 功能特性
- 基于内存的限流实现
- 支持配置化限流参数
- 可通过配置文件启用/禁用
- 返回标准的限流响应

#### 依赖库
```bash
go get github.com/ulule/limiter/v3
```

#### 实现代码
```go
func RateLimit() gin.HandlerFunc {
    cfg := config.GetConfig()

    if !cfg.RateLimit.Enabled {
        return func(c *gin.Context) {
            c.Next()
        }
    }

    // 创建限流器配置
    rate := limiter.Rate{
        Period: time.Duration(cfg.RateLimit.Window) * time.Second,
        Limit:  int64(cfg.RateLimit.Requests),
    }

    // 创建内存存储
    store := memory.NewStore()
    
    // 创建限流器
    instance := limiter.New(store, rate)
    
    // 返回限流中间件
    middleware := stdlib.NewMiddleware(instance)
    
    // 处理限流逻辑...
}
```

#### 配置参数
在 `config/config.yaml` 中：
```yaml
rateLimit:
  enabled: true
  requests: 100   # requests per minute
  window: 60      # seconds
```

#### 响应格式
```json
{
    "code": 429,
    "message": "请求过于频繁，请稍后再试",
    "data": null
}
```

### 2. 异常处理中间件 (Recovery)

#### 文件位置
`internal/middleware/recovery.go`

#### 功能特性
- 捕获运行时 panic
- 开发/生产环境不同的错误响应
- 记录错误堆栈信息
- 统一的错误处理格式

#### 实现代码
```go
func Recovery() gin.HandlerFunc {
    return func(c *gin.Context) {
        defer func() {
            if err := recover(); err != nil {
                // 记录堆栈信息
                stack := debug.Stack()
                
                // 根据环境返回不同响应
                if config.GetConfig().Server.Mode == "debug" {
                    // 开发环境返回详细错误
                    c.JSON(http.StatusInternalServerError, gin.H{
                        "code": 500,
                        "message": "服务器内部错误",
                        "data": gin.H{
                            "error": err,
                            "stack": string(stack),
                        },
                    })
                } else {
                    // 生产环境返回简单错误
                    c.JSON(http.StatusInternalServerError, gin.H{
                        "code": 500,
                        "message": "服务器内部错误",
                        "data": nil,
                    })
                }
                c.Abort()
            }
        }()
        c.Next()
    }
}
```

### 3. JWT 认证中间件 (Auth)

#### 文件位置
- JWT 工具包: `internal/pkg/jwt/jwt.go`
- 认证中间件: `internal/middleware/auth.go`

#### 功能特性
- JWT Token 生成、解析、刷新
- 支持访问 Token 和刷新 Token
- Bearer Token 格式验证
- 用户信息注入到上下文

#### 依赖库
```bash
go get github.com/golang-jwt/jwt/v5
```

#### JWT 工具包实现
```go
type Claims struct {
    UserID   uint   `json:"userId"`
    Username string `json:"username"`
    jwt.RegisteredClaims
}

func GenerateToken(userID uint, username string) (string, error)
func ParseToken(tokenString string) (*Claims, error)
func RefreshToken(refreshTokenString string) (string, error)
func ValidateToken(tokenString string) bool
```

#### 认证中间件实现
```go
func Auth() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 获取 Authorization 头
        authHeader := c.GetHeader("Authorization")
        
        // 检查 Bearer 格式
        if !strings.HasPrefix(authHeader, "Bearer ") {
            c.JSON(http.StatusUnauthorized, gin.H{
                "code": 401,
                "message": "认证格式错误",
                "data": nil,
            })
            c.Abort()
            return
        }

        // 解析 Token
        tokenString := strings.TrimPrefix(authHeader, "Bearer ")
        claims, err := jwt.ParseToken(tokenString)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{
                "code": 401,
                "message": "认证信息无效",
                "data": gin.H{"error": err.Error()},
            })
            c.Abort()
            return
        }

        // 将用户信息存储到上下文
        c.Set("userId", claims.UserID)
        c.Set("username", claims.Username)

        c.Next()
    }
}
```

#### 配置参数
```yaml
jwt:
  secret: "your-secret-key-here"
  accessTokenExpire: 7   # days
  refreshTokenExpire: 30 # days
```

#### 使用方式
```go
// 需要认证的路由
group.Use(middleware.Auth())

// 可选认证的路由
group.Use(middleware.OptionalAuth())
```

### 4. 权限中间件 (Permission)

#### 文件位置
`internal/middleware/permission.go`

#### 功能特性
- 基于角色的权限控制 (RBAC)
- 权限代码检查
- 管理员权限快捷方法
- 可配置的权限验证

#### 权限类型
- **角色权限**: 基于用户角色进行验证
- **权限代码**: 基于具体权限进行验证

#### 实现代码
```go
// 角色权限检查
func RequireRole(roles ...string) gin.HandlerFunc {
    return func(c *gin.Context) {
        userID, exists := c.Get("userId")
        if !exists {
            c.JSON(http.StatusUnauthorized, gin.H{
                "code": 401,
                "message": "用户未认证",
                "data": nil,
            })
            c.Abort()
            return
        }

        // TODO: 从数据库查询用户角色
        userRoles := getUserRoles(userID.(uint))
        
        // 检查用户是否有所需角色
        hasRole := false
        for _, requiredRole := range roles {
            for _, userRole := range userRoles {
                if userRole == requiredRole {
                    hasRole = true
                    break
                }
            }
        }
        
        if !hasRole {
            c.JSON(http.StatusForbidden, gin.H{
                "code": 403,
                "message": "权限不足",
                "data": gin.H{
                    "required": roles,
                    "current": userRoles,
                },
            })
            c.Abort()
            return
        }
        
        c.Next()
    }
}

// 权限代码检查
func RequirePermission(permissions ...string) gin.HandlerFunc {
    // 类似实现，检查权限代码...
}

// 快捷方法
func AdminOnly() gin.HandlerFunc {
    return RequireRole("admin", "super_admin")
}
```

#### 使用示例
```go
// 需要管理员权限
POST   /api/v1/system/user/create   -> middleware.AdminOnly()
PUT    /api/v1/system/user/update   -> middleware.Auth()
DELETE /api/v1/system/user/delete   -> middleware.AdminOnly()
```

### 5. 操作日志中间件 (OperationLogger)

#### 文件位置
`internal/middleware/operation_log.go`

#### 功能特性
- 记录所有 HTTP 请求的操作日志
- 敏感信息过滤
- 请求耗时统计
- 用户信息关联

#### 日志结构
```go
type OperationLog struct {
    ID        uint      `json:"id"`
    UserID    uint      `json:"userId"`
    Username  string    `json:"username"`
    Method    string    `json:"method"`
    Path      string    `json:"path"`
    Params    string    `json:"params"`
    Body      string    `json:"body"`
    IP        string    `json:"ip"`
    UserAgent string    `json:"userAgent"`
    Status    int       `json:"status"`
    Duration  int64     `json:"duration"`
    ErrorMsg  string    `json:"errorMsg"`
    CreatedAt time.Time `json:"createdAt"`
}
```

#### 实现要点
```go
func OperationLogger() gin.HandlerFunc {
    return func(c *gin.Context) {
        startTime := time.Now()
        
        // 读取请求体
        var bodyBytes []byte
        if c.Request.Body != nil {
            bodyBytes, _ = io.ReadAll(c.Request.Body)
            c.Request.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
        }
        
        // 获取用户信息
        userID, _ := c.Get("userId")
        username, _ := c.Get("username")
        
        // 创建日志记录
        log := OperationLog{
            UserID:    userID.(uint),
            Username:  username.(string),
            Method:    c.Request.Method,
            Path:      c.Request.URL.Path,
            Params:    c.Request.URL.RawQuery,
            IP:        c.ClientIP(),
            UserAgent: c.GetHeader("User-Agent"),
            CreatedAt: startTime,
        }
        
        // 过滤敏感数据
        if c.Request.Method == "POST" || c.Request.Method == "PUT" {
            contentType := c.GetHeader("Content-Type")
            if strings.Contains(contentType, "application/json") {
                filteredBody := filterSensitiveData(bodyBytes)
                log.Body = string(filteredBody)
            }
        }
        
        // 使用自定义 ResponseWriter 捕获响应
        responseWriter := &responseBodyWriter{
            ResponseWriter: c.Writer,
            body:           &bytes.Buffer{},
        }
        c.Writer = responseWriter
        
        c.Next()
        
        // 计算耗时和状态
        log.Duration = time.Since(startTime).Milliseconds()
        log.Status = c.Writer.Status()
        
        if len(c.Errors) > 0 {
            log.ErrorMsg = c.Errors.Last().Error()
        }
        
        // TODO: 保存到数据库
        printOperationLog(log)
    }
}
```

#### 敏感数据过滤
```go
func filterSensitiveData(data []byte) []byte {
    sensitiveFields := []string{"password", "password_confirmation", "secret", "token", "key"}
    
    var obj interface{}
    json.Unmarshal(data, &obj)
    
    if m, ok := obj.(map[string]interface{}); ok {
        for _, field := range sensitiveFields {
            if _, exists := m[field]; exists {
                m[field] = "***"
            }
        }
    }
    
    filtered, _ := json.Marshal(obj)
    return filtered
}
```

## 中间件配置

### 全局中间件顺序
在 `internal/router/router.go` 中的配置顺序：
```go
// 添加中间件
r.Use(gin.Logger())                    // 1. Gin 自带日志
r.Use(middleware.Recovery())          // 2. 自定义异常处理
r.Use(middleware.RateLimit())         // 3. 限流中间件
r.Use(middleware.OperationLogger())   // 4. 操作日志中间件

// CORS 中间件
if cfg.CORS.Enabled {
    r.Use(corsMiddleware(cfg.CORS))   // 5. CORS 中间件
}
```

### 路由级中间件
```go
// 系统管理模块
system := v1.Group("/system")
{
    // 需要认证的路由
    user := system.Group("/user")
    user.Use(middleware.Auth()) // 认证中间件
    {
        user.GET("/page", nil)                    // 查询 - 只需认证
        user.POST("/create", middleware.AdminOnly()) // 创建 - 需要管理员权限
        user.DELETE("/delete", middleware.AdminOnly()) // 删除 - 需要管理员权限
    }
}
```

## 中间件目录结构
```
internal/middleware/
├── rate_limit.go      # 限流中间件
├── recovery.go        # 异常处理中间件
├── auth.go           # 认证中间件
├── permission.go     # 权限中间件
└── operation_log.go  # 操作日志中间件

internal/pkg/jwt/
└── jwt.go           # JWT 工具包
```

## 配置文件支持

所有中间件都支持通过配置文件进行配置：
```yaml
# JWT 配置
jwt:
  secret: "your-secret-key-here"
  accessTokenExpire: 7
  refreshTokenExpire: 30

# 限流配置
rateLimit:
  enabled: true
  requests: 100
  window: 60

# CORS 配置
cors:
  enabled: true
  allowOrigins: ["*"]
  allowMethods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"]
  allowHeaders: ["*"]
  exposeHeaders: []
  allowCredentials: false
  maxAge: 86400
```

## 响应格式统一

所有中间件都使用统一的响应格式：
```json
{
    "code": <状态码>,
    "message": "<错误信息>",
    "data": <响应数据>
}
```

### 状态码说明
- `401`: 未认证或认证失败
- `403`: 权限不足
- `429`: 请求过于频繁
- `500`: 服务器内部错误

## 性能考虑

1. **限流中间件**: 使用内存存储，性能高但重启后状态丢失
2. **认证中间件**: JWT 解析开销较小
3. **权限中间件**: 当前使用硬编码，后续优化为数据库查询
4. **操作日志**: 记录详细但有一定性能开销

## 扩展性

1. **限流中间件**: 可扩展为 Redis 存储
2. **权限中间件**: 支持动态权限配置
3. **操作日志**: 可扩展为异步批量写入
4. **认证中间件**: 支持多种认证方式

## 下一步优化

1. 实现权限的数据库动态查询
2. 优化操作日志的存储方式
3. 添加缓存支持提高权限验证性能
4. 实现更细粒度的权限控制
5. 添加中间件性能监控