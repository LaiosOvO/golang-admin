# 配置文件加载实现

## 概述

本阶段实现了基于 Viper 的配置文件加载功能，支持多环境配置、环境变量覆盖、配置验证和热加载等特性。

## 技术选型

### 核心库
- **Viper**: 配置管理库，支持多种配置格式
  - 支持 YAML/JSON/TOML 等格式
  - 支持环境变量覆盖
  - 支持配置文件监听和热加载
  - 支持配置合并

### 依赖库
```go
require (
    github.com/spf13/viper v1.18.2
    github.com/fsnotify/fsnotify v1.7.0
)
```

## 配置结构设计

### 主配置结构
```go
type Config struct {
    Server      ServerConfig      `yaml:"server" json:"server"`
    Database    DatabaseConfig    `yaml:"database" json:"database"`
    Kafka       KafkaConfig       `yaml:"kafka" json:"kafka"`
    AI          AIConfig          `yaml:"ai" json:"ai"`
    JWT         JWTConfig         `yaml:"jwt" json:"jwt"`
    Log         LogConfig         `yaml:"log" json:"log"`
    CORS        CORSConfig        `yaml:"cors" json:"cors"`
    RateLimit   RateLimitConfig   `yaml:"rateLimit" json:"rateLimit"`
    Upload      UploadConfig      `yaml:"upload" json:"upload"`
}
```

### 数据库配置结构
支持多种数据库类型：
- **MySQL**: 主数据库
- **PostgreSQL**: 扩展数据库，支持 PostGIS 和 pgvector
- **MongoDB**: 文档数据库
- **Redis**: 缓存数据库
- **Elasticsearch**: 全文搜索引擎
- **Milvus**: 向量数据库

## 多环境支持

### 配置文件结构
```
config/
├── config.yaml         # 默认配置
├── config.dev.yaml     # 开发环境
├── config.test.yaml    # 测试环境
└── config.prod.yaml    # 生产环境
```

### 环境变量
- `APP_ENV`: 指定运行环境（dev/test/prod）
- 支持环境变量覆盖配置项，如 `SERVER_PORT` 覆盖 `server.port`

### 配置加载策略
1. 加载默认配置 `config.yaml`
2. 根据环境加载环境特定配置 `config.{env}.yaml`
3. 合并配置（环境配置覆盖默认配置）
4. 应用环境变量覆盖

## 核心功能实现

### 1. 配置加载函数

#### Load() - 加载默认配置
```go
func Load(configPath string) error {
    viper.SetConfigName("config")
    viper.SetConfigType("yaml")
    viper.AddConfigPath(configPath)
    
    if err := viper.ReadInConfig(); err != nil {
        return fmt.Errorf("配置文件未找到: %w", err)
    }
    
    GlobalConfig = &Config{}
    if err := viper.Unmarshal(GlobalConfig); err != nil {
        return fmt.Errorf("解析配置失败: %w", err)
    }
    
    return validateConfig()
}
```

#### LoadWithEnv() - 环境特定配置加载
```go
func LoadWithEnv(env string) error {
    // 加载默认配置
    viper.SetConfigName("config")
    viper.ReadInConfig()
    
    // 合并环境配置
    envConfigFile := filepath.Join(configDir, fmt.Sprintf("config.%s.yaml", env))
    viper.SetConfigFile(envConfigFile)
    viper.MergeInConfig()
    
    // 环境变量覆盖
    viper.AutomaticEnv()
    
    return validateConfig()
}
```

### 2. 配置验证

#### validateConfig() - 主验证函数
```go
func validateConfig() error {
    if GlobalConfig == nil {
        return fmt.Errorf("配置为空")
    }
    
    // 验证服务器配置
    if GlobalConfig.Server.Port <= 0 || GlobalConfig.Server.Port > 65535 {
        return fmt.Errorf("服务器端口配置无效: %d", GlobalConfig.Server.Port)
    }
    
    // 验证数据库配置
    if err := validateDatabaseConfig(); err != nil {
        return fmt.Errorf("数据库配置验证失败: %w", err)
    }
    
    // 验证JWT配置
    if GlobalConfig.JWT.Secret == "" {
        return fmt.Errorf("JWT密钥不能为空")
    }
    
    return nil
}
```

### 3. 便捷函数

#### 环境判断函数
```go
func IsDebug() bool      { return GetConfig().Server.Mode == "debug" }
func IsRelease() bool    { return GetConfig().Server.Mode == "release" }
func IsTest() bool       { return GetConfig().Server.Mode == "test" }
```

#### 全局配置获取
```go
func GetConfig() *Config {
    if GlobalConfig == nil {
        panic("配置未初始化，请先调用 Load() 函数")
    }
    return GlobalConfig
}
```

### 4. 热加载支持（可选）
```go
func WatchConfig(callback func(*Config)) error {
    viper.WatchConfig()
    viper.OnConfigChange(func(e fsnotify.Event) {
        // 重新解析和验证配置
        newConfig := &Config{}
        if err := viper.Unmarshal(newConfig); err != nil {
            fmt.Printf("解析新配置失败: %v\n", err)
            return
        }
        
        // 验证新配置
        if err := validateConfig(); err != nil {
            fmt.Printf("新配置验证失败: %v\n", err)
            return
        }
        
        // 调用回调函数
        if callback != nil {
            callback(GlobalConfig)
        }
    })
    return nil
}
```

## 配置文件示例

### 开发环境配置 (config.dev.yaml)
```yaml
server:
  port: 8080
  mode: debug
  name: "Gin Admin Pro (Dev)"

database:
  mysql:
    host: localhost
    port: 3306
    database: gin_admin_dev
    username: root
    password: password

rateLimit:
  enabled: false  # 开发环境关闭限流

cors:
  allowOrigins: ["http://localhost:3000", "http://localhost:8080"]
  allowCredentials: true
```

### 生产环境配置 (config.prod.yaml)
```yaml
server:
  port: 8080
  mode: release
  name: "Gin Admin Pro"

database:
  mysql:
    host: ${MYSQL_HOST}
    port: ${MYSQL_PORT:3306}
    database: ${MYSQL_DATABASE}
    username: ${MYSQL_USERNAME}
    password: ${MYSQL_PASSWORD}

rateLimit:
  enabled: true
  requests: 100
  window: 60
```

## 在应用中的使用

### main.go 中的集成
```go
func main() {
    // 获取环境变量
    env := os.Getenv("APP_ENV")
    if env == "" {
        env = "dev"
    }

    // 加载配置
    var err error
    if env == "dev" || env == "test" || env == "prod" {
        err = config.LoadWithEnv(env)
    } else {
        err = config.Load("")
    }
    
    if err != nil {
        log.Fatalf("加载配置失败: %v", err)
    }

    // 获取配置
    cfg := config.GetConfig()
    fmt.Printf("服务器启动在端口 %d\n", cfg.Server.Port)
}
```

## 测试实现

### 单元测试覆盖
- ✅ 配置验证功能测试
- ✅ 环境判断函数测试
- ✅ 全局配置获取测试
- ✅ 错误处理测试
- ✅ 配置结构体验证

### 测试文件
```
internal/pkg/config/
├── config.go
├── types.go
└── config_test.go
```

### 运行测试
```bash
go test ./internal/pkg/config/ -v
```

## 安全考虑

### 1. 敏感信息保护
- 生产环境使用环境变量存储敏感信息
- 配置文件中不包含密码等敏感信息
- JWT 密钥使用强随机字符串

### 2. 配置验证
- 端口范围验证
- 必填字段验证
- 数据库连接参数验证

### 3. 环境隔离
- 不同环境使用不同的数据库
- 测试环境禁用危险功能
- 生产环境启用限流和安全策略

## 性能考虑

### 1. 配置缓存
- 全局配置对象缓存
- 避免重复解析配置文件

### 2. 延迟加载
- 配置按需初始化
- 避免启动时的性能开销

## 扩展性

### 1. 新配置项添加
- 在 types.go 中添加新的配置结构体字段
- 在验证函数中添加相应的验证逻辑

### 2. 新环境支持
- 创建新的环境配置文件
- 在 LoadWithEnv 函数中添加环境判断

### 3. 配置源扩展
- 支持从配置中心加载配置
- 支持从远程配置服务加载

## 常见问题

### 1. 配置文件找不到
确保配置文件位于正确的路径：
```
gin-admin-pro/
├── config/
│   ├── config.yaml
│   ├── config.dev.yaml
│   ├── config.test.yaml
│   └── config.prod.yaml
```

### 2. 环境变量不生效
确保环境变量命名正确：
- `server.port` -> `SERVER_PORT`
- `database.mysql.host` -> `DATABASE_MYSQL_HOST`

### 3. 配置验证失败
检查必填配置项：
- JWT 密钥不能为空
- 数据库连接参数必须完整
- 端口号必须在有效范围内

## 总结

配置文件加载模块已完成以下功能：
- ✅ 基于 Viper 的配置加载
- ✅ 多环境配置支持
- ✅ 环境变量覆盖
- ✅ 配置验证
- ✅ 单元测试覆盖
- ✅ 安全性和性能考虑

该模块为后续的数据库集成、Web框架配置等提供了坚实的基础。